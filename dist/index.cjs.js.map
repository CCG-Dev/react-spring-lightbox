{"version":3,"file":"index.cjs.js","sources":["../src/components/ImageStage/utils/getTranslateOffsetsFromScale.ts","../src/components/ImageStage/utils/imageIsOutOfBounds.ts","../src/components/ImageStage/components/Image/index.tsx","../src/components/ImageStage/utils/useDoubleClick.tsx","../src/components/ImageStage/components/ImagePager/index.tsx","../src/components/ImageStage/components/SSRImagePager/SSRImagePager.tsx","../src/components/ImageStage/index.tsx","../src/components/ImageStage/utils/useRefSize.tsx","../src/components/PageContainer/index.tsx","../src/components/CreatePortal/index.tsx","../src/index.tsx"],"sourcesContent":["type IGetTranslateOffsetsFromScale = {\n    /** The current [x,y] translate values of image */\n    currentTranslate: [translateX: number, translateY: number];\n    /** The image dom node used as a reference to calculate translate offsets */\n    imageRef: React.RefObject<HTMLImageElement>;\n    /** The amount of change in the new transform scale */\n    pinchDelta: number;\n    /** The current transform scale of image */\n    scale: number;\n    /** The [x,y] coordinates of the zoom origin */\n    touchOrigin: [touchOriginX: number, touchOriginY: number];\n};\n\ntype ITranslateOffsetsReturnType = [translateX: number, translateY: number];\n\n/**\n * Calculates the the translate(x,y) coordinates needed to zoom-in\n * to a point in an image.\n *\n * @returns {array} The next [x,y] translate values to apply to image\n */\nconst getTranslateOffsetsFromScale = ({\n    currentTranslate: [translateX, translateY],\n    imageRef,\n    pinchDelta,\n    scale,\n    touchOrigin: [touchOriginX, touchOriginY],\n}: IGetTranslateOffsetsFromScale): ITranslateOffsetsReturnType => {\n    if (!imageRef?.current) {\n        return [0, 0];\n    }\n\n    const {\n        height: imageHeight,\n        left: imageTopLeftX,\n        top: imageTopLeftY,\n        width: imageWidth,\n    } = imageRef.current?.getBoundingClientRect();\n\n    // Get the (x,y) touch position relative to image origin at the current scale\n    const imageCoordX = (touchOriginX - imageTopLeftX - imageWidth / 2) / scale;\n    const imageCoordY =\n        (touchOriginY - imageTopLeftY - imageHeight / 2) / scale;\n\n    // Calculate translateX/Y offset at the next scale to zoom to touch position\n    const newTranslateX = -imageCoordX * pinchDelta + translateX;\n    const newTranslateY = -imageCoordY * pinchDelta + translateY;\n\n    return [newTranslateX, newTranslateY];\n};\n\nexport default getTranslateOffsetsFromScale;\n","/**\n * Determines if the provided image is within the viewport\n *\n * @returns True if image needs to be resized to fit viewport, otherwise false\n */\nconst imageIsOutOfBounds = (\n    imageRef: React.RefObject<HTMLImageElement>,\n): boolean => {\n    // If no ref is provided, return false\n    if (!imageRef.current) {\n        return false;\n    }\n\n    const {\n        bottom: bottomRightY,\n        left: topLeftX,\n        right: bottomRightX,\n        top: topLeftY,\n    } = imageRef.current?.getBoundingClientRect();\n    const { innerHeight: windowHeight, innerWidth: windowWidth } = window;\n\n    if (\n        topLeftX > windowWidth * (1 / 2) ||\n        topLeftY > windowHeight * (1 / 2) ||\n        bottomRightX < windowWidth * (1 / 2) ||\n        bottomRightY < windowHeight * (1 / 2)\n    )\n        return true;\n\n    return false;\n};\n\nexport default imageIsOutOfBounds;\n","import React, {\n    useEffect,\n    useRef,\n    useState,\n} from 'react';\n\nimport { useGesture } from 'react-use-gesture';\nimport styled, { AnyStyledComponent } from 'styled-components';\n\nimport {\n    animated,\n    to,\n    useSpring,\n} from '@react-spring/web';\n\nimport type { ImagesListItem } from '../../../../types/ImagesList';\nimport {\n    getTranslateOffsetsFromScale,\n    imageIsOutOfBounds,\n    useDoubleClick,\n} from '../../utils';\n\nconst defaultImageTransform = {\n    pinching: false,\n    scale: 1,\n    translateX: 0,\n    translateY: 0,\n};\n\ntype IImageProps = {\n    /** Any valid <img /> props to pass to the lightbox img element ie src, alt, caption etc*/\n    imgProps: ImagesListItem;\n    /** Affects Width calculation method, depending on whether the Lightbox is Inline or not */\n    inline: boolean;\n    /** True if this image is currently shown in pager, otherwise false */\n    isCurrentImage: boolean;\n    /** A React component that is rendered when the image is loading */\n    loadingComponent?: React.ReactNode;\n    /** Callback function to update the zoom level in the parent ImagePager */\n    onZoomLevelChange?: (zoomLevel: number) => void;\n    /** Fixed height of the image stage, used to restrict maximum height of images */\n    pagerHeight: '100%' | number;\n    /** Indicates parent ImagePager is in a state of dragging, if true click to zoom is disabled */\n    pagerIsDragging: boolean;\n    /** Function that can be called to disable dragging in the pager */\n    setDisableDrag: (disable: boolean) => void;\n    /** Show zoom icons on hover */\n    showZoomIconsOnHover?: boolean;\n    /** Overrides the default behavior of double clicking causing an image zoom to a single click */\n    singleClickToZoom: boolean;\n    /** Zoom level */\n    zoomLevel?: number;\n};\n\n/**\n * Animates pinch-zoom + panning on image using spring physics\n */\nconst Image = ({\n    imgProps: { style: imgStyleProp, ...restImgProps },\n    inline,\n    isCurrentImage,\n    loadingComponent,\n    onZoomLevelChange,\n    pagerHeight,\n    pagerIsDragging,\n    setDisableDrag,\n    showZoomIconsOnHover,\n    singleClickToZoom,\n    zoomLevel,\n}: IImageProps) => {\n    const [isPanningImage, setIsPanningImage] = useState<boolean>(false);\n    const [loading, setLoading] = useState<boolean>(true);\n    const imageRef = useRef<HTMLImageElement>(null);\n\n    /**\n     * Animates scale and translate offsets of Image as they change in gestures\n     *\n     * @see https://www.react-spring.io/docs/hooks/use-spring\n     */\n    const [{ scale, translateX, translateY }, springApi] = useSpring(() => ({\n        ...defaultImageTransform,\n        onChange: (result, instance) => {\n            if (result.value.scale < 1 || !result.value.pinching) {\n                instance.start(defaultImageTransform);\n            }\n\n            if (result.value.scale > 1 && imageIsOutOfBounds(imageRef)) {\n                instance.start(defaultImageTransform);\n            }\n        },\n        // Enable dragging in ImagePager if image is at the default size\n        onRest: (result, instance) => {\n            if (result.value.scale === 1) {\n                instance.start(defaultImageTransform);\n                setDisableDrag(false);\n            }\n        },\n    }));\n\n    useEffect(() => {\n        if (isCurrentImage) {\n            const scaleValue = scale.get();\n\n            const zoomLevelNumber = zoomLevel || 1;\n            if (zoomLevelNumber === scaleValue) return;\n            if (scaleValue < zoomLevelNumber) {\n                handleZoomIn(zoomLevelNumber - scaleValue);\n            }\n            if (scaleValue > zoomLevelNumber) {\n                handleZoomOut(scaleValue - zoomLevelNumber);\n            }\n        }\n    }, [zoomLevel]);\n\n    // Reset scale of this image when dragging to new image in ImagePager\n    useEffect(() => {\n        if (!isCurrentImage && scale.get() !== 1) {\n            springApi.start(defaultImageTransform);\n        }\n    }, [isCurrentImage, scale, springApi]);\n\n    /**\n     * Update Image scale and translate offsets during pinch/pan gestures\n     *\n     * @see https://github.com/react-spring/react-use-gesture#usegesture-hook-supporting-multiple-gestures-at-once\n     */\n    useGesture(\n        {\n            onDrag: ({\n                cancel,\n                first,\n                memo = { initialTranslateX: 0, initialTranslateY: 0 },\n                movement: [xMovement, yMovement],\n                pinching,\n                tap,\n                touches,\n            }) => {\n                if (pagerIsDragging || scale.get() === 1 || tap) {\n                    return;\n                }\n\n                // Disable click to zoom during drag\n                if (xMovement && yMovement && !isPanningImage) {\n                    setIsPanningImage(true);\n                }\n\n                if (touches > 1) {\n                    return;\n                }\n                if (pinching || scale.get() <= 1) {\n                    return;\n                }\n\n                // Prevent dragging image out of viewport\n                if (scale.get() > 1 && imageIsOutOfBounds(imageRef)) {\n                    cancel();\n                    return;\n                } else {\n                    if (first) {\n                        return {\n                            initialTranslateX: translateX.get(),\n                            initialTranslateY: translateY.get(),\n                        };\n                    }\n\n                    // Translate image from dragging\n                    springApi.start({\n                        translateX: memo.initialTranslateX + xMovement,\n                        translateY: memo.initialTranslateY + yMovement,\n                    });\n\n                    return memo;\n                }\n            },\n            onDragEnd: ({ memo }) => {\n                if (memo !== undefined) {\n                    // Add small timeout to prevent onClick handler from firing after drag\n                    setTimeout(() => setIsPanningImage(false), 100);\n                }\n            },\n            onPinch: ({\n                cancel,\n                ctrlKey,\n                event,\n                last,\n                movement: [xMovement],\n                origin: [touchOriginX, touchOriginY],\n            }) => {\n                if (pagerIsDragging) {\n                    return;\n                }\n\n                // Prevent ImagePager from registering isDragging\n                setDisableDrag(true);\n\n                // Disable click to zoom during pinch\n                if (xMovement && !isPanningImage) {\n                    setIsPanningImage(true);\n                }\n\n                // Don't calculate new translate offsets on final frame\n                if (last) {\n                    cancel();\n                    return;\n                }\n\n                // Speed up pinch zoom when using mouse versus touch\n                const SCALE_FACTOR = ctrlKey ? 1000 : 250;\n                const pinchScale = scale.get() + xMovement / SCALE_FACTOR;\n                const pinchDelta = pinchScale - scale.get();\n\n                /**\n                 * Calculate touch origin for pinch/zoom\n                 *\n                 * if event is a touch event (React.TouchEvent<Element>, TouchEvent or WebKitGestureEvent) use touchOriginX/Y\n                 * if event is a wheel event (React.WheelEvent<Element> or WheelEvent) use the mouse cursor's clientX/Y\n                 */\n                let touchOrigin: [touchOriginX: number, touchOriginY: number] =\n                    [touchOriginX, touchOriginY];\n                if ('clientX' in event && 'clientY' in event && ctrlKey) {\n                    touchOrigin = [event.clientX, event.clientY];\n                }\n\n                // Calculate the amount of x, y translate offset needed to\n                // zoom-in to point as image scale grows\n                const [newTranslateX, newTranslateY] =\n                    getTranslateOffsetsFromScale({\n                        currentTranslate: [translateX.get(), translateY.get()],\n                        imageRef,\n                        pinchDelta,\n                        scale: scale.get(),\n                        // Use the [x, y] coords of mouse if a trackpad or ctrl + wheel event\n                        // Otherwise use touch origin\n                        touchOrigin,\n                    });\n\n                // Restrict the amount of zoom between half and 3x image size\n                if (pinchScale < 0.5) {\n                    springApi.start({ pinching: true, scale: 0.5 });\n                } else if (pinchScale > 3.0) {\n                    springApi.start({ pinching: true, scale: 3.0 });\n                } else {\n                    springApi.start({\n                        pinching: true,\n                        scale: pinchScale,\n                        translateX: newTranslateX,\n                        translateY: newTranslateY,\n                    });\n                }\n            },\n            onPinchEnd: () => {\n                if (!pagerIsDragging) {\n                    if (scale.get() > 1) {\n                        setDisableDrag(true);\n                    } else {\n                        springApi.start(defaultImageTransform);\n                    }\n                    // Add small timeout to prevent onClick handler from firing after panning\n                    setTimeout(() => setIsPanningImage(false), 100);\n                }\n            },\n        },\n        /**\n         * useGesture config\n         * @see https://github.com/react-spring/react-use-gesture#usegesture-config\n         */\n        {\n            domTarget: imageRef as React.RefObject<EventTarget>,\n            drag: {\n                filterTaps: true,\n            },\n            enabled: !inline,\n            eventOptions: {\n                passive: false,\n            },\n        },\n    );\n\n    // Handle click/tap on image\n    useDoubleClick({\n        [singleClickToZoom ? 'onSingleClick' : 'onDoubleClick']: (\n            e: MouseEvent,\n        ) => {\n            if (pagerIsDragging || isPanningImage) {\n                e.stopPropagation();\n                return;\n            }\n\n            // If tapped while already zoomed-in, zoom out to default scale\n            if (scale.get() !== 1) {\n                springApi.start(defaultImageTransform);\n                onZoomLevelChange && onZoomLevelChange(1);\n                return;\n            }\n\n            // Zoom-in to origin of click on image\n            const { clientX: touchOriginX, clientY: touchOriginY } = e;\n            const pinchScale = scale.get() + 1;\n            const pinchDelta = pinchScale - scale.get();\n\n            // Calculate the amount of x, y translate offset needed to\n            // zoom-in to point as image scale grows\n            const [newTranslateX, newTranslateY] = getTranslateOffsetsFromScale(\n                {\n                    currentTranslate: [translateX.get(), translateY.get()],\n                    imageRef,\n                    pinchDelta,\n                    scale: scale.get(),\n                    touchOrigin: [touchOriginX, touchOriginY],\n                },\n            );\n            onZoomLevelChange && onZoomLevelChange(pinchScale);\n\n            // Disable dragging in pager\n            setDisableDrag(true);\n            springApi.start({\n                pinching: true,\n                scale: pinchScale,\n                translateX: newTranslateX,\n                translateY: newTranslateY,\n            });\n        },\n        enabled: !inline,\n        latency: singleClickToZoom ? 0 : 200,\n        ref: imageRef,\n    });\n\n    const handleZoomIn = (scaleIncrease?: number) => {\n        // Zoom-in to origin of click on image\n        const pinchScale = scale.get() + (scaleIncrease || 0.5);\n        const pinchDelta = pinchScale - scale.get();\n\n        const touchOriginX = window.innerWidth / 2;\n        const touchOriginY = window.innerHeight / 2;\n\n        const [newTranslateX, newTranslateY] = getTranslateOffsetsFromScale({\n            currentTranslate: [translateX.get(), translateY.get()],\n            imageRef,\n            pinchDelta,\n            scale: scale.get(),\n            touchOrigin: [touchOriginX, touchOriginY],\n        });\n\n        onZoomLevelChange && onZoomLevelChange(pinchScale);\n\n        // Disable dragging in pager\n        setDisableDrag(true);\n        springApi.start({\n            pinching: true,\n            scale: pinchScale,\n            translateX: newTranslateX,\n            translateY: newTranslateY,\n        });\n    };\n\n    const handleZoomOut = (scaleDecrease?: number) => {\n        // Zoom-in to origin of click on image\n        if (scale.get() === 1) {\n            return;\n        }\n        const pinchScale = scale.get() - (scaleDecrease || 0.5);\n        const pinchDelta = pinchScale - scale.get();\n\n        const touchOriginX = window.innerWidth / 2;\n        const touchOriginY = window.innerHeight / 2;\n\n        const [newTranslateX, newTranslateY] = getTranslateOffsetsFromScale({\n            currentTranslate: [translateX.get(), translateY.get()],\n            imageRef,\n            pinchDelta,\n            scale: scale.get(),\n            touchOrigin: [touchOriginX, touchOriginY],\n        });\n\n        onZoomLevelChange && onZoomLevelChange(pinchScale);\n\n        // Disable dragging in pager\n        setDisableDrag(true);\n        springApi.start({\n            pinching: true,\n            scale: pinchScale,\n            translateX: newTranslateX,\n            translateY: newTranslateY,\n        });\n    };\n\n    return (\n        <>\n            <AnimatedImage\n                $enableHoverZoom={showZoomIconsOnHover}\n                $inline={inline}\n                $loading={loading}\n                $scale={zoomLevel}\n                className=\"lightbox-image\"\n                draggable=\"false\"\n                onClick={(e: React.MouseEvent<HTMLImageElement>) => {\n                    // Don't close lighbox when clicking image\n                    e.stopPropagation();\n                    e.nativeEvent.stopImmediatePropagation();\n                }}\n                onDragStart={(e: React.DragEvent<HTMLImageElement>) => {\n                    // Disable image ghost dragging in firefox\n                    e.preventDefault();\n                }}\n                onLoad={() => setLoading(false)}\n                onLoadStart={() => setLoading(true)}\n                ref={imageRef}\n                style={{\n                    ...imgStyleProp,\n                    maxHeight: pagerHeight,\n                    transform: to(\n                        [scale, translateX, translateY],\n                        (s, x, y) => `translate(${x}px, ${y}px) scale(${s})`,\n                    ),\n                    ...(isCurrentImage && { willChange: 'transform' }),\n                }}\n                // Include any valid img html attributes provided in the <Lightbox /> images prop\n                {...(restImgProps as React.ComponentProps<typeof animated.img>)}\n            />\n            {loading && (\n                <>\n                    {loadingComponent ? (\n                        (loadingComponent as React.ReactElement)\n                    ) : (\n                        <LoadingSpinner />\n                    )}\n                </>\n            )}\n        </>\n    );\n};\n\nImage.displayName = 'Image';\n\nexport default Image;\n\nconst AnimatedImage = styled(animated.img as AnyStyledComponent)`\n    width: auto;\n    height: auto;\n    max-width: 100%;\n    user-select: none;\n    touch-action: ${({ $inline }) => (!$inline ? 'none' : 'pan-y')};\n    transition: opacity 0.25s ease-out;\n    ${({ $enableHoverZoom, $scale }) => {\n        return `\n            ${\n                $enableHoverZoom &&\n                ($scale === 1 ? `cursor: zoom-in;` : `cursor: zoom-out;`)\n            }\n        \n        `;\n    }}\n    ${({ $loading }) =>\n        $loading\n            ? `\n            width: 0;\n    height: 0;\n        opacity: 0;\n    `\n            : `\n            opacity: 1;\n      \n            `}\n    ::selection {\n        background: none;\n    }\n`;\n\nconst LoadingSpinner = styled.div`\n    display: inline-block;\n    width: 80px;\n    height: 80px;\n\n    &:after {\n        content: '';\n        display: block;\n        width: 64px;\n        height: 64px;\n        margin: 8px;\n        border-radius: 50%;\n        border: 6px solid #fff;\n        border-color: #fff transparent #fff transparent;\n        animation: lds-dual-ring 1.2s linear infinite;\n    }\n    @keyframes lds-dual-ring {\n        0% {\n            transform: rotate(0deg);\n        }\n        100% {\n            transform: rotate(360deg);\n        }\n    }\n`;\n","import React, { useEffect } from 'react';\n\ntype IUseDoubleClickProps = {\n    /** Set to false to disable onDoubleClick/onSingleClick  */\n    enabled?: boolean;\n    /** The amount of time (in milliseconds) to wait before differentiating a single from a double click */\n    latency?: number;\n    /** A callback function for double click events */\n    onDoubleClick?: (event: MouseEvent) => void;\n    /** A callback function for single click events */\n    onSingleClick?: (event: MouseEvent) => void;\n    /** Dom node to watch for double clicks */\n    ref: React.RefObject<HTMLElement>;\n};\n\n/**\n * React Hook that returns the current window size\n * and report updates from the 'resize' window event\n */\nconst useDoubleClick = ({\n    enabled = true,\n    latency = 300,\n    onDoubleClick = () => null,\n    onSingleClick = () => null,\n    ref,\n}: IUseDoubleClickProps) => {\n    useEffect(() => {\n        const clickRef = ref.current;\n        let clickCount = 0;\n        let timer: ReturnType<typeof setTimeout>;\n\n        const handleClick = (e: MouseEvent) => {\n            if (enabled) {\n                clickCount += 1;\n\n                timer = setTimeout(() => {\n                    if (clickCount === 1) onSingleClick(e);\n                    else if (clickCount === 2) onDoubleClick(e);\n\n                    clickCount = 0;\n                }, latency);\n            }\n        };\n\n        // Add event listener for click events\n        clickRef?.addEventListener('click', handleClick);\n\n        // Remove event listener\n        return () => {\n            clickRef?.removeEventListener('click', handleClick);\n\n            if (timer) {\n                clearTimeout(timer);\n            }\n        };\n    });\n};\n\nexport default useDoubleClick;\n","import React, {\n    useEffect,\n    useRef,\n    useState,\n} from 'react';\n\nimport { useGesture } from 'react-use-gesture';\nimport styled, { AnyStyledComponent } from 'styled-components';\n\nimport {\n    animated,\n    useSprings,\n} from '@react-spring/web';\n\nimport type { ImagesList } from '../../../../types/ImagesList';\nimport Image from '../Image';\n\ntype IImagePager = {\n    /** Index of image in images array that is currently shown */\n    currentIndex: number;\n    /** Overrides the default behavior of mousewheel */\n    disableMouseWheel?: boolean;\n    /** image stage height */\n    imageStageHeight: number;\n    /** image stage width */\n    imageStageWidth: number;\n    /** Array of image objects to be shown in Lightbox */\n    images: ImagesList;\n    /** Affects Width calculation method, depending on whether the Lightbox is Inline or not */\n    inline: boolean;\n    /** A React component that is rendered when the image is loading */\n    loadingComponent?: React.ReactNode;\n    /** Function that closes the Lightbox */\n    onClose?: () => void;\n    /** Function that can be called to disable dragging in the pager */\n    onNext: () => void;\n    /** True if this image is currently shown in pager, otherwise false */\n    onPrev: () => void;\n    /** Callback function to update the zoom level in the parent ImagePager */\n    onZoomLevelChange?: (zoomLevel: number) => void;\n    /** A React component that renders inside the image stage, useful for making overlays over the image */\n    renderImageOverlay: () => React.ReactNode;\n    /** Show zoom icons on hover */\n    showZoomIconsOnHover?: boolean;\n    /** Overrides the default behavior of double clicking causing an image zoom to a single click */\n    singleClickToZoom: boolean;\n    /** Zoom level */\n    zoomLevel?: number;\n};\n\n/**\n * Gesture controlled surface that animates prev/next page changes via spring physics.\n */\nconst ImagePager = ({\n    currentIndex,\n    disableMouseWheel,\n    images,\n    imageStageHeight,\n    imageStageWidth,\n    inline,\n    loadingComponent,\n    onClose,\n    onNext,\n    onPrev,\n    onZoomLevelChange,\n    renderImageOverlay,\n    showZoomIconsOnHover,\n    singleClickToZoom,\n    zoomLevel,\n}: IImagePager) => {\n    const firstRender = useRef(true);\n\n    const [disableDrag, setDisableDrag] = useState<boolean>(false);\n    const [pagerHeight, setPagerHeight] = useState<'100%' | number>('100%');\n    const [isDragging, setIsDragging] = useState<boolean>(false);\n\n    //Determine the absolute height of the image pager\n    useEffect(() => {\n        const currPagerHeight = inline\n            ? imageStageHeight\n            : imageStageHeight - 50;\n\n        if (currPagerHeight !== pagerHeight) {\n            setPagerHeight(currPagerHeight);\n        }\n    }, [inline, pagerHeight, imageStageHeight]);\n\n    // Generate page positions based on current index\n    const getPagePositions = React.useCallback(\n        (i: number, down = false, xDelta = 0) => {\n            const x =\n                (i - currentIndex) * imageStageWidth + (down ? xDelta : 0);\n\n            if (i < currentIndex - 1 || i > currentIndex + 1) {\n                return { display: 'none', x };\n            }\n            return { display: 'flex', x };\n        },\n        [currentIndex, imageStageWidth],\n    );\n\n    /**\n     * Animates translateX of all images at the same time\n     *\n     * @see https://www.react-spring.io/docs/hooks/use-springs\n     */\n    const [pagerSprings, springsApi] = useSprings(images.length, (i) =>\n        getPagePositions(i),\n    );\n\n    // Animate page change if currentIndex changes\n    useEffect(() => {\n        // No need to set page position for initial render\n        if (firstRender.current) {\n            firstRender.current = false;\n            return;\n        }\n        // Update page positions after prev/next page state change\n        springsApi.start((i) => getPagePositions(i));\n    }, [currentIndex, getPagePositions, springsApi]);\n\n    /**\n     * Update each Image's visibility and translateX offset during dragging\n     *\n     * @see https://github.com/react-spring/react-use-gesture\n     */\n    const bind = useGesture(\n        {\n            onDrag: ({\n                active,\n                cancel,\n                direction: [xDir],\n                distance,\n                down,\n                movement: [xMovement],\n                tap,\n                touches,\n                velocity,\n            }) => {\n                // Disable drag if Image has been zoomed in to allow for panning\n                if (disableDrag || xMovement === 0 || tap) {\n                    return;\n                }\n                if (!isDragging) {\n                    setIsDragging(true);\n                }\n\n                const isHorizontalDrag = Math.abs(xDir) > 0.7;\n                const draggedFarEnough =\n                    down &&\n                    isHorizontalDrag &&\n                    distance > imageStageWidth / 3.5;\n                const draggedFastEnough =\n                    down && isHorizontalDrag && velocity > 2;\n\n                // Handle next/prev image from valid drag\n                if ((draggedFarEnough || draggedFastEnough) && active) {\n                    const goToIndex = xDir > 0 ? -1 : 1;\n\n                    // Cancel gesture event\n                    cancel();\n\n                    if (goToIndex > 0) {\n                        onNext();\n                    } else if (goToIndex < 0) {\n                        onPrev();\n                    }\n                    return;\n                }\n\n                // Don't move pager during two+ finger touch events, i.e. pinch-zoom\n                if (touches > 1) {\n                    cancel();\n                    return;\n                }\n\n                // Update page x-coordinates for single finger/mouse gestures\n                springsApi.start((i) => getPagePositions(i, down, xMovement));\n                return;\n            },\n            onDragEnd: () => {\n                if (isDragging) {\n                    springsApi.start((i) => getPagePositions(i));\n                    // Add small timeout buffer to prevent event handlers from firing in child Images\n                    setTimeout(() => setIsDragging(false), 100);\n                }\n            },\n            onWheel: ({ ctrlKey, direction: [xDir, yDir], velocity }) => {\n                // Disable drag if Image has been zoomed in to allow for panning\n                if (ctrlKey || disableDrag || velocity === 0) {\n                    return;\n                }\n\n                if (!isDragging) {\n                    setIsDragging(true);\n                }\n\n                if (disableMouseWheel) return;\n\n                const draggedFastEnough = velocity > 1.1;\n\n                // Handle next/prev image from valid drag\n                if (draggedFastEnough) {\n                    const goToIndex = xDir + yDir > 0 ? -1 : 1;\n\n                    if (goToIndex > 0) {\n                        onNext();\n                    } else if (goToIndex < 0) {\n                        onPrev();\n                    }\n                }\n            },\n            onWheelEnd: () => {\n                springsApi.start((i) => getPagePositions(i));\n                // Add small timeout buffer to prevent event handlers from firing in child Images\n                setTimeout(() => setIsDragging(false), 100);\n            },\n        },\n        {\n            drag: {\n                filterTaps: true,\n            },\n            wheel: {\n                enabled: !inline,\n            },\n        },\n    );\n\n    return (\n        <ImagePagerContainer>\n            {pagerSprings.map(({ display, x }, i) => (\n                <AnimatedImagePager\n                    $inline={inline}\n                    {...bind()}\n                    className=\"lightbox-image-pager\"\n                    key={i}\n                    onClick={() => {\n                        if (onClose) {\n                            return (\n                                Math.abs(x.get()) < 1 &&\n                                !disableDrag &&\n                                onClose()\n                            );\n                        }\n                    }}\n                    role=\"presentation\"\n                    style={{\n                        display,\n                        transform: x.to(\n                            (xInterp: number) => `translateX(${xInterp}px)`,\n                        ),\n                    }}\n                >\n                    <PagerContentWrapper>\n                        <PagerInnerContentWrapper>\n                            <ImageContainer\n                                $inline={inline}\n                                onClick={(e) => {\n                                    e.stopPropagation();\n                                    e.nativeEvent.stopImmediatePropagation();\n                                }}\n                            >\n                                <Image\n                                    imgProps={images[i]}\n                                    inline={inline}\n                                    isCurrentImage={i === currentIndex}\n                                    loadingComponent={loadingComponent}\n                                    onZoomLevelChange={onZoomLevelChange}\n                                    pagerHeight={pagerHeight}\n                                    pagerIsDragging={isDragging}\n                                    setDisableDrag={setDisableDrag}\n                                    showZoomIconsOnHover={showZoomIconsOnHover}\n                                    singleClickToZoom={singleClickToZoom}\n                                    zoomLevel={zoomLevel}\n                                />\n                                {renderImageOverlay()}\n                            </ImageContainer>\n                        </PagerInnerContentWrapper>\n                    </PagerContentWrapper>\n                </AnimatedImagePager>\n            ))}\n        </ImagePagerContainer>\n    );\n};\n\nImagePager.displayName = 'ImagePager';\n\nexport default ImagePager;\n\nconst ImagePagerContainer = styled.div`\n    height: 100%;\n    width: 100%;\n`;\n\nconst PagerInnerContentWrapper = styled.div`\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\n\nconst PagerContentWrapper = styled.div`\n    width: 100%;\n    display: flex;\n    justify-content: center;\n`;\n\nconst AnimatedImagePager = styled(animated.span as AnyStyledComponent)<{\n    $inline: boolean;\n}>`\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    right: 0px;\n    bottom: 0px;\n    height: 100%;\n    width: 100%;\n    will-change: transform;\n    touch-action: ${({ $inline }) => (!$inline ? 'none' : 'pan-y')};\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n`;\n\nconst ImageContainer = styled.div<{ $inline: boolean }>`\n    position: relative;\n    touch-action: ${({ $inline }) => (!$inline ? 'none' : 'pan-y')};\n    user-select: none;\n    display: flex;\n    justify-content: center;\n    width: 100%;\n`;\n","import type { ImagesList } from '../../../../types/ImagesList';\nimport styled, { css } from 'styled-components';\nimport * as React from 'react';\n\ntype ISSRImagePagerProps = {\n    currentIndex: number;\n    images: ImagesList;\n};\n\nconst SSRImagePager = ({ currentIndex, images }: ISSRImagePagerProps) => {\n    return (\n        <ImagePagerContainer>\n            {images.map(({ alt, src }, i) => {\n                return (\n                    <Image\n                        $isCurrentImage={i === currentIndex}\n                        alt={alt}\n                        key={`${alt}-${src}-${i}`}\n                        src={src}\n                    />\n                );\n            })}\n        </ImagePagerContainer>\n    );\n};\n\nexport default SSRImagePager;\n\nconst ImagePagerContainer = styled.div`\n    width: 100%;\n    height: inherit;\n`;\n\nconst Image = styled.img<{ $isCurrentImage: boolean }>`\n    ${({ $isCurrentImage }) =>\n        !$isCurrentImage &&\n        css`\n            visibility: hidden;\n            display: none;\n        `}\n    height:100%;\n    width: 100%;\n    object-fit: contain;\n`;\n","import React from 'react';\n\nimport styled from 'styled-components';\n\nimport type { ImagesList } from '../../types/ImagesList';\nimport ImagePager from './components/ImagePager';\nimport SSRImagePager from './components/SSRImagePager/SSRImagePager';\nimport useRefSize from './utils/useRefSize';\n\ntype IImageStageProps = {\n    /** classnames are applied to the root ImageStage component */\n    className?: string;\n    /** Index of image in images array that is currently shown */\n    currentIndex: number;\n    /** Overrides the default behavior of mousewheel */\n    disableMouseWheel?: boolean;\n    /** Array of image objects to be shown in Lightbox */\n    images: ImagesList;\n    /** Affects Width calculation method, depending on whether the Lightbox is Inline or not */\n    inline: boolean;\n    /** A React component that is rendered when the image is loading */\n    loadingComponent?: React.ReactNode;\n    /** Function that closes the Lightbox */\n    onClose?: () => void;\n    /** Function that can be called to disable dragging in the pager */\n    onNext: () => void;\n    /** True if this image is currently shown in pager, otherwise false */\n    onPrev: () => void;\n    /** Callback function to update the zoom level in the parent ImagePager */\n    onZoomLevelChange?: (zoomLevel: number) => void;\n    /** A React component that renders inside the image stage, useful for making overlays over the image */\n    renderImageOverlay: () => React.ReactNode;\n    /** A React component that is used for next button in image pager */\n    renderNextButton: ({ canNext }: { canNext: boolean }) => React.ReactNode;\n    /** A React component that is used for previous button in image pager */\n    renderPrevButton: ({ canPrev }: { canPrev: boolean }) => React.ReactNode;\n    /** Show zoom icons on hover */\n    showZoomIconsOnHover?: boolean;\n    /** Overrides the default behavior of double clicking causing an image zoom to a single click */\n    singleClickToZoom: boolean;\n    /** Zoom level */\n    zoomLevel?: number;\n};\n\n/**\n * Containing element for ImagePager and prev/next button controls\n */\nconst ImageStage = ({\n    className = '',\n    currentIndex,\n    disableMouseWheel,\n    images,\n    inline,\n    loadingComponent,\n    onClose,\n    onNext,\n    onPrev,\n    onZoomLevelChange,\n    renderImageOverlay,\n    renderNextButton,\n    renderPrevButton,\n    showZoomIconsOnHover,\n    singleClickToZoom,\n    zoomLevel,\n}: IImageStageProps) => {\n    // Extra sanity check that the next/prev image exists before moving to it\n    const canPrev = currentIndex > 0;\n    const canNext = currentIndex + 1 < images.length;\n\n    const onNextImage = canNext ? onNext : () => null;\n    const onPrevImage = canPrev ? onPrev : () => null;\n\n    const onCloseImage = () => {\n        onZoomLevelChange && onZoomLevelChange(1);\n        onClose?.();\n    };\n\n    const [{ height: containerHeight, width: containerWidth }, containerRef] =\n        useRefSize();\n\n    return (\n        <ImageStageContainer\n            className={className}\n            data-testid=\"lightbox-image-stage\"\n            ref={containerRef}\n        >\n            {renderPrevButton({ canPrev })}\n            {containerWidth ? (\n                <ImagePager\n                    currentIndex={currentIndex}\n                    disableMouseWheel={disableMouseWheel}\n                    images={images}\n                    imageStageHeight={containerHeight}\n                    imageStageWidth={containerWidth}\n                    inline={inline}\n                    loadingComponent={loadingComponent}\n                    onClose={onCloseImage}\n                    onNext={onNextImage}\n                    onPrev={onPrevImage}\n                    onZoomLevelChange={onZoomLevelChange}\n                    renderImageOverlay={renderImageOverlay}\n                    showZoomIconsOnHover={showZoomIconsOnHover}\n                    singleClickToZoom={singleClickToZoom}\n                    zoomLevel={zoomLevel}\n                />\n            ) : inline ? (\n                <SSRImagePager currentIndex={currentIndex} images={images} />\n            ) : null}\n            {renderNextButton({ canNext })}\n        </ImageStageContainer>\n    );\n};\n\nexport default ImageStage;\n\nconst ImageStageContainer = styled.div`\n    position: relative;\n    height: 100%;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\n","import { useCallback, useEffect, useRef, useState } from 'react';\n\ntype RefSize = {\n    height: number;\n    width: number;\n};\n\ntype Node = HTMLDivElement | null;\n\ntype IUseRefSize = [refSize: RefSize, elementRef: (node: any) => void | null];\n\n/**\n * React Hook that returns the current ref size\n * and report updates from the 'resize' ref event\n *\n * @returns {RefSize} An object containing the ref width and height\n * @returns {elementRef} A callback ref to be used on the container being measured\n */\nconst useRefSize = (): IUseRefSize => {\n    const ref = useRef<HTMLDivElement>(null);\n\n    const [node, setNode] = useState<Node>(null);\n    const [refSize, setRefSize] = useState<RefSize>({\n        height: ref.current?.clientHeight || 0,\n        width: ref.current?.clientWidth || 0,\n    });\n\n    const elementRef = useCallback((node: Node) => {\n        if (node !== null) {\n            setNode(node);\n\n            setRefSize({\n                height: node.clientHeight,\n                width: node.clientWidth,\n            });\n        }\n    }, []);\n\n    useEffect(() => {\n        const handleResize = () => {\n            if (node) {\n                const height = node.clientHeight;\n                const width = node.clientWidth;\n                if (height !== refSize.height || width !== refSize.width) {\n                    setRefSize({\n                        height,\n                        width,\n                    });\n                }\n            }\n        };\n\n        window.addEventListener('resize', handleResize);\n        window.addEventListener('orientationchange', handleResize);\n\n        return () => {\n            window.removeEventListener('resize', handleResize);\n            window.removeEventListener('orientationchange', handleResize);\n        };\n    }, [node, refSize.height, refSize.width]);\n\n    return [refSize, elementRef];\n};\n\nexport default useRefSize;\n","import React from 'react';\nimport { useTransition, animated, config } from '@react-spring/web';\nimport styled, { AnyStyledComponent } from 'styled-components';\n\ntype IPageContainerProps = {\n    /** All child components of Lightbox */\n    children: React.ReactNode[];\n    /** Classes are applied to the root lightbox component */\n    className: string;\n    /** Flag that dictates if the lightbox is open or closed */\n    isOpen: boolean;\n    /** React-Spring useTransition config for page open/close animation */\n    pageTransitionConfig: any;\n    /** Inline styles are applied to the root lightbox component */\n    style: React.CSSProperties;\n};\n\n/**\n * Animates the lightbox as it opens/closes\n */\nconst PageContainer = ({\n    children,\n    className,\n    isOpen,\n    pageTransitionConfig,\n    style,\n}: IPageContainerProps) => {\n    const defaultTransition = {\n        config: { ...config.default, friction: 32, mass: 1, tension: 320 },\n        enter: { opacity: 1, transform: 'scale(1)' },\n        from: { opacity: 0, transform: 'scale(0.75)' },\n        leave: { opacity: 0, transform: 'scale(0.75)' },\n    };\n\n    const transitions = useTransition(isOpen, {\n        ...defaultTransition,\n        ...pageTransitionConfig,\n    });\n\n    return (\n        <>\n            {transitions(\n                (animatedStyles, item) =>\n                    item && (\n                        <AnimatedPageContainer\n                            className={`lightbox-container${\n                                className ? ` ${className}` : ''\n                            }`}\n                            data-testid=\"lightbox-container\"\n                            style={{ ...animatedStyles, ...style }}\n                        >\n                            {children}\n                        </AnimatedPageContainer>\n                    ),\n            )}\n        </>\n    );\n};\n\nexport default PageContainer;\n\nconst AnimatedPageContainer = styled(animated.div as AnyStyledComponent)`\n    display: flex;\n    flex-direction: column;\n    position: fixed;\n    z-index: 400;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n`;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\ntype ICreatePortal = {\n    children: any;\n};\n\n/**\n * Creates a SSR + next.js friendly React Portal inside <body />\n *\n * Child components are rendered on the client side only\n\n * @see https://reactjs.org/docs/portals.html\n */\nclass CreatePortal extends React.Component<ICreatePortal> {\n    portalContainer: HTMLDivElement;\n    body: HTMLElement;\n\n    // Only executes on the client-side\n    componentDidMount() {\n        // Get the document body\n        this.body = document.body;\n\n        // Create a container <div /> for React Portal\n        this.portalContainer = document.createElement('div');\n        this.portalContainer.setAttribute('class', 'lightbox-portal');\n\n        // Append the container to the document body\n        this.body.appendChild(this.portalContainer);\n\n        // Force a re-render as we're on the client side now\n        // children prop will render to portalContainer\n        this.forceUpdate();\n\n        // Add event listener to prevent trackpad/ctrl+mousewheel zooming of lightbox\n        // Zooming is handled specifically within /ImageStage/components/Image\n        this.portalContainer.addEventListener('wheel', this.preventWheel);\n    }\n\n    componentWillUnmount() {\n        // Remove wheel event listener\n        this.portalContainer.removeEventListener('wheel', this.preventWheel);\n\n        // Cleanup Portal from DOM\n        this.body.removeChild(this.portalContainer);\n    }\n\n    preventWheel = (e: WheelEvent) => e.preventDefault();\n\n    render() {\n        // Return null during SSR\n        if (this.portalContainer === undefined) return null;\n\n        const { children } = this.props;\n\n        return <>{ReactDOM.createPortal(children, this.portalContainer)}</>;\n    }\n}\n\nexport default CreatePortal;\n","import React, { useEffect } from 'react';\n\nimport {\n    CreatePortal,\n    ImageStage,\n    PageContainer,\n} from './components';\nimport type { ImagesList } from './types/ImagesList';\n\nexport type ImagesListType = ImagesList;\n\ntype ILightboxProps = {\n    /** classnames are applied to the root lightbox component */\n    className?: string;\n    /** Index of image in images array that is currently shown */\n    currentIndex: number;\n    /** Overrides the default behavior of mousewheel */\n    disableMouseWheel?: boolean;\n    /** Array of images to be shown in Lightbox, each image object may contain any valid 'img' attribute with the exceptions of 'draggable', 'onClick', 'onDragStart' and 'ref' */\n    images: ImagesList;\n    /** Determines whether the Lightbox returns just an Inline carousel (ImageStage) */\n    inline?: boolean;\n    /** Flag that dictates if the lightbox is open or closed */\n    isOpen: boolean;\n    /** A React component that is rendered when the image is loading */\n    loadingComponent?: React.ReactNode;\n    /** Function that closes the Lightbox */\n    onClose?: () => void;\n    /** Function that changes currentIndex to next image in images */\n    onNext: () => void;\n    /** Function that changes currentIndex to previous image in images */\n    onPrev: () => void;\n    /** Callback function to update the zoom level in the parent ImagePager */\n    onZoomLevelChange?: (zoomLevel: number) => void;\n    /** React-Spring useTransition config for page open/close animation */\n    pageTransitionConfig?: any;\n    /** A React component that renders below the image pager */\n    renderFooter?: () => React.ReactNode;\n    /** A React component that renders above the image pager */\n    renderHeader?: () => React.ReactNode;\n    /** A React component that renders inside the image stage, useful for making overlays over the image */\n    renderImageOverlay?: () => React.ReactNode;\n    /** A React component that is used for next button in image pager */\n    renderNextButton?: ({ canNext }: { canNext: boolean }) => React.ReactNode;\n    /** A React component that is used for previous button in image pager */\n    renderPrevButton?: ({ canPrev }: { canPrev: boolean }) => React.ReactNode;\n    /** Show zoom icons on hover */\n    showZoomIconsOnHover?: boolean;\n    /** Overrides the default behavior of double clicking causing an image zoom to a single click */\n    singleClickToZoom?: boolean;\n    /** Inline styles that are applied to the root lightbox component */\n    style?: React.CSSProperties;\n    /** Zoom level */\n    zoomLevel?: number;\n};\n\n/**\n * Gesture controlled lightbox that interpolates animations with spring physics.\n *\n * Demos and docs:\n * @see https://timellenberger.com/libraries/react-spring-lightbox\n *\n * GitHub repo:\n * @see https://github.com/tim-soft/react-spring-lightbox\n *\n * Built with:\n * @see https://github.com/react-spring/react-use-gesture\n * @see https://github.com/react-spring/react-spring\n * @see https://github.com/styled-components/styled-components\n */\nconst Lightbox = ({\n    className = '',\n    currentIndex,\n    disableMouseWheel = false,\n    images = [],\n    inline = false,\n    isOpen,\n    loadingComponent = null,\n    onClose,\n    onNext,\n    onPrev,\n    onZoomLevelChange,\n    pageTransitionConfig = null,\n    renderFooter = () => null,\n    renderHeader = () => null,\n    renderImageOverlay = () => null,\n    renderNextButton = () => null,\n    renderPrevButton = () => null,\n    showZoomIconsOnHover = false,\n    singleClickToZoom = false,\n    style = {},\n    zoomLevel,\n}: ILightboxProps) => {\n    // Handle event listeners for keyboard\n    useEffect(() => {\n        /**\n         * Prevent keyboard from controlling background page\n         * when lightbox is open\n         */\n        const preventBackgroundScroll = (e: KeyboardEvent) => {\n            const keysToIgnore = [\n                'ArrowUp',\n                'ArrowDown',\n                'End',\n                'Home',\n                'PageUp',\n                'PageDown',\n            ];\n\n            if (isOpen && keysToIgnore.includes(e.key)) e.preventDefault();\n        };\n\n        /**\n         * Navigate images with arrow keys, close on Esc key\n         */\n        const handleKeyboardInput = (e: KeyboardEvent) => {\n            if (isOpen) {\n                switch (e.key) {\n                    case 'ArrowLeft':\n                        onPrev();\n                        break;\n                    case 'ArrowRight':\n                        onNext();\n                        break;\n                    case 'Escape':\n                        onClose && onClose();\n                        break;\n                    default:\n                        e.preventDefault();\n                        break;\n                }\n            }\n        };\n\n        document.addEventListener('keyup', handleKeyboardInput);\n        document.addEventListener('keydown', preventBackgroundScroll);\n\n        return () => {\n            document.removeEventListener('keyup', handleKeyboardInput);\n            document.removeEventListener('keydown', preventBackgroundScroll);\n        };\n    });\n\n    const imageStage = (\n        <ImageStage\n            currentIndex={currentIndex}\n            disableMouseWheel={disableMouseWheel}\n            images={images}\n            inline={inline}\n            loadingComponent={loadingComponent}\n            onClose={onClose}\n            onNext={onNext}\n            onPrev={onPrev}\n            onZoomLevelChange={onZoomLevelChange}\n            renderImageOverlay={renderImageOverlay}\n            renderNextButton={renderNextButton}\n            renderPrevButton={renderPrevButton}\n            showZoomIconsOnHover={showZoomIconsOnHover}\n            singleClickToZoom={singleClickToZoom}\n            zoomLevel={zoomLevel}\n        />\n    );\n\n    if (inline) {\n        return imageStage;\n    }\n\n    return (\n        <CreatePortal>\n            <PageContainer\n                className={className}\n                isOpen={isOpen}\n                pageTransitionConfig={pageTransitionConfig}\n                style={style}\n            >\n                {renderHeader()}\n                {imageStage}\n                {renderFooter()}\n            </PageContainer>\n        </CreatePortal>\n    );\n};\n\nexport default Lightbox;\n"],"names":["getTranslateOffsetsFromScale","_ref","currentTranslate","translateX","translateY","imageRef","pinchDelta","scale","touchOrigin","touchOriginX","touchOriginY","current","height","imageHeight","left","imageTopLeftX","top","imageTopLeftY","width","imageWidth","getBoundingClientRect","imageIsOutOfBounds","bottom","bottomRightY","topLeftX","right","bottomRightX","topLeftY","innerHeight","windowHeight","innerWidth","windowWidth","window","defaultImageTransform","pinching","Image","imgProps","style","imgStyleProp","inline","isCurrentImage","loadingComponent","onZoomLevelChange","pagerHeight","pagerIsDragging","setDisableDrag","showZoomIconsOnHover","singleClickToZoom","zoomLevel","restImgProps","_objectWithoutProperties","_excluded","isPanningImage","setIsPanningImage","useState","loading","setLoading","useRef","springApi","useSpring","_objectSpread","onChange","result","instance","value","start","onRest","useEffect","scaleValue","get","zoomLevelNumber","handleZoomIn","handleZoomOut","useGesture","onDrag","_ref2","cancel","first","memo","initialTranslateX","initialTranslateY","movement","xMovement","yMovement","tap","touches","onDragEnd","_ref3","undefined","setTimeout","onPinch","_ref4","ctrlKey","event","last","origin","SCALE_FACTOR","pinchScale","clientX","clientY","newTranslateX","newTranslateY","onPinchEnd","domTarget","drag","filterTaps","enabled","eventOptions","passive","latency","onDoubleClick","onSingleClick","ref","clickRef","timer","clickCount","handleClick","e","addEventListener","removeEventListener","clearTimeout","useDoubleClick","stopPropagation","scaleIncrease","scaleDecrease","React","default","createElement","Fragment","AnimatedImage","_extends","$enableHoverZoom","$inline","$loading","$scale","className","draggable","onClick","nativeEvent","stopImmediatePropagation","onDragStart","preventDefault","onLoad","onLoadStart","maxHeight","transform","to","s","x","y","willChange","LoadingSpinner","displayName","styled","animated","img","_ref5","_ref6","_ref7","div","ImagePager","currentIndex","disableMouseWheel","images","imageStageHeight","imageStageWidth","onClose","onNext","onPrev","renderImageOverlay","firstRender","disableDrag","setPagerHeight","isDragging","setIsDragging","currPagerHeight","getPagePositions","useCallback","i","arguments","length","display","pagerSprings","springsApi","useSprings","bind","active","direction","xDir","distance","down","velocity","isHorizontalDrag","Math","abs","goToIndex","onWheel","yDir","onWheelEnd","wheel","ImagePagerContainer","map","AnimatedImagePager","key","role","xInterp","PagerContentWrapper","PagerInnerContentWrapper","ImageContainer","span","SSRImagePager","alt","src","$isCurrentImage","css","ImageStage","renderNextButton","renderPrevButton","canPrev","canNext","onNextImage","onPrevImage","containerHeight","containerWidth","containerRef","useRefSize","node","setNode","refSize","setRefSize","clientHeight","clientWidth","elementRef","handleResize","ImageStageContainer","onCloseImage","PageContainer","children","isOpen","pageTransitionConfig","defaultTransition","config","friction","mass","tension","enter","opacity","from","leave","transitions","useTransition","animatedStyles","item","AnimatedPageContainer","CreatePortal","Component","constructor","super","_defineProperty","this","componentDidMount","body","document","portalContainer","setAttribute","appendChild","forceUpdate","preventWheel","componentWillUnmount","removeChild","render","props","ReactDOM","createPortal","renderFooter","renderHeader","preventBackgroundScroll","includes","handleKeyboardInput","imageStage"],"mappings":"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"}